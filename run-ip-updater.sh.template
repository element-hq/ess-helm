#!/bin/bash

# Wrapper script to run the update-dynamic-ip.py script
# This script sources configuration, sets environment variables,
# and then executes the Python script.

# Determine the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

# Define paths relative to the SCRIPT_DIR
# Assuming config.sh is in the parent directory of SCRIPT_DIR (e.g., project root)
CONFIG_FILE_PATH="${SCRIPT_DIR}/../config.sh"
# Assuming the Python script (after template processing) is in the same directory as this wrapper
PYTHON_SCRIPT_PATH="${SCRIPT_DIR}/update-dynamic-ip.py"

# --- Sanity Checks ---
if [ ! -f "$CONFIG_FILE_PATH" ]; then
    echo "ERROR: Configuration file '$CONFIG_FILE_PATH' not found. Please run setup.sh first."
    exit 1
fi

if [ ! -f "$PYTHON_SCRIPT_PATH" ]; then
    echo "ERROR: Python script '$PYTHON_SCRIPT_PATH' not found. Ensure it has been generated from its template."
    exit 1
fi

# --- Load Configuration ---
# Use shellcheck directive to specify the source file for static analysis if available
# shellcheck source=../config.sh
# (The above line is a comment for shellcheck, not active shell code for sourcing)
if ! source "$CONFIG_FILE_PATH"; then
    echo "ERROR: Failed to source configuration file '$CONFIG_FILE_PATH'."
    exit 1
fi
echo "Configuration file '$CONFIG_FILE_PATH' sourced successfully."

# --- Export necessary variables for the Python script ---
# These names MUST match the os.getenv() calls in the Python script.

export ROUTEROS_IP
export ROUTEROS_USERNAME
export ROUTEROS_PASSWORD
export WAN_INTERFACE

export CLOUDFLARE_API_TOKEN
export CLOUDFLARE_EMAIL # Derived in config.sh as acme@DOMAIN
export DOMAIN

# Construct comma-separated list of subdomains for the Python script
# Ensure these variables are loaded from config.sh
SUBDOMAINS_TO_UPDATE_LIST=""
[ -n "$MATRIX_SUBDOMAIN" ] && SUBDOMAINS_TO_UPDATE_LIST="${SUBDOMAINS_TO_UPDATE_LIST}${MATRIX_SUBDOMAIN},"
[ -n "$ELEMENT_SUBDOMAIN" ] && SUBDOMAINS_TO_UPDATE_LIST="${SUBDOMAINS_TO_UPDATE_LIST}${ELEMENT_SUBDOMAIN},"
[ -n "$RTC_SUBDOMAIN" ] && SUBDOMAINS_TO_UPDATE_LIST="${SUBDOMAINS_TO_UPDATE_LIST}${RTC_SUBDOMAIN},"
[ -n "$MAS_SUBDOMAIN" ] && SUBDOMAINS_TO_UPDATE_LIST="${SUBDOMAINS_TO_UPDATE_LIST}${MAS_SUBDOMAIN},"
[ -n "$TURN_SUBDOMAIN" ] && SUBDOMAINS_TO_UPDATE_LIST="${SUBDOMAINS_TO_UPDATE_LIST}${TURN_SUBDOMAIN},"
# Remove trailing comma if any
export SUBDOMAINS_TO_UPDATE="${SUBDOMAINS_TO_UPDATE_LIST%,}"

export HELM_NAMESPACE
export HELM_RELEASE_NAME

export DNS_UPDATE_INTERVAL
export INSTALL_DIR

# Determine Python executable
PYTHON_EXECUTABLE=""
if command -v python3 &> /dev/null; then
    PYTHON_EXECUTABLE="python3"
elif command -v python &> /dev/null; then
    PYTHON_EXECUTABLE="python"
else
    echo "ERROR: Python (python3 or python) command not found in PATH."
    exit 1
fi
echo "Using Python executable: $PYTHON_EXECUTABLE"

# Define how pip should be called (preferring 'python -m pip')
PYTHON_PIP_CMD="${PYTHON_EXECUTABLE} -m pip"
if ! $PYTHON_PIP_CMD --version &> /dev/null; then
    echo "Warning: '${PYTHON_EXECUTABLE} -m pip' not working, trying direct pip3/pip."
    if command -v pip3 &> /dev/null; then
        PYTHON_PIP_CMD="pip3"
    elif command -v pip &> /dev/null;
        PYTHON_PIP_CMD="pip"
    else
        echo "ERROR: pip (pip3 or pip) command not found. Cannot install Python script dependencies."
        # exit 1 # Decide if this is fatal here or let Python script handle it
    fi
fi
export PYTHON_PIP_EXECUTABLE="$PYTHON_PIP_CMD" # Pass this to Python script for installing its own deps
echo "Using Pip command for Python script: $PYTHON_PIP_EXECUTABLE"


# --- Run the Python script ---
echo "Starting Dynamic IP Updater Python script ($PYTHON_SCRIPT_PATH)..."
# The Python script should be made executable (chmod +x) by the setup process if needed,
# or called directly with the interpreter. Calling with interpreter is safer.

"$PYTHON_EXECUTABLE" "$PYTHON_SCRIPT_PATH"

# Capture exit code of the python script
exit_code=$?
echo "Dynamic IP Updater Python script has exited with code $exit_code."

# Optional: Add restart logic here if the script is meant to run as a daemon
# and exits unexpectedly. For cron, no restart logic is needed here.
# For systemd, systemd would handle restarts.

exit $exit_code
